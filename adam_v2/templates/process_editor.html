{% extends "base.html" %}


{% block content %}
<script src="{{url_for('static', filename='drawflow.min.js')}}"></script>
<link rel="stylesheet" href="{{url_for('static', filename='drawflow_theme_dark.css')}}" />
<link rel="stylesheet" href="{{url_for('static', filename='process_editor.css')}}" />
<link rel="stylesheet" href="{{url_for('static', filename='drawflow.min.css')}}") />

<div id="body">

<!-- Object Inspector -->
<div id="inspector">
	<div class="btn-inspector-inline" onclick="hide_or_show('inspector')">
		X
	</div>

	<div id="inspectorheader" draggable="true">
		Object Inspector
	</div>

	<!-- This seems simpler and better than a table -->
	<div class="row" id="inspector_rows">
		<div class="column" id="inspector_column1">
			Column 1
		</div>
		<div class="column" id="inspector_column2">
			Column 2
		</div>
	</div>
 </div>



  <div class="wrapper">
    <div class="col">
    <div class="pe_selector">
        <form method=post action="/process_editor">
        	{{stf.theme}}
          <input type=submit value=Change>
        </form>
    </div>


        <div class="item_grid">
			{% for item in flist %}
					<div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="{{item}}">
						<img draggable="false" src="/static/themes/{{theme}}/{{item}}"></img>
						<i class="{{item.strip('.svg')}}"></i>
					</div>
			{% endfor %}
        </div>

	   <div class="item_grid">
       <div class="pe_modify_element">
			<div class="drag-input-connector" draggable="true" ondragstart="drag(event)">
			<img draggable="false" src="/static/input-svgrepo-com.svg"></img>
			</div>
			<div class="drag-output-connector" draggable="true" ondragstart="drag(event)">
			<img draggable="false" src="/static/output-svgrepo-com.svg"></img>
			</div>
       </div>
       </div>
      
    </div>
    <div class="col-right">
    
      <div id="drawflow" ondrop="drop(event)" ondragover="allowDrop(event)">

        <div class="btn-export" onclick="console.log(editor.export())">Export</div>
         <div class="btn-inspector" onclick="hide_or_show('inspector')">INSPECTOR</div>
        <div class="btn-clear" onclick="editor.clearModuleSelected()">Clear</div>
        <div class="btn-hide-cheat">
            <div   class="cs_shown" onclick="hideCheat('show')" id="cs_shown">CHEATSHEET</div>
            <div   class="cs_hidden" onclick="hideCheat('hide')" id="cs_hidden" style="display:none" >HIDE</div>
        </div>
        <div class="btn-lock">
          <img id="lock" class="procedit_locked" onclick="editor.editor_mode='fixed'; changeMode('lock');"  src="{{url_for('static', filename='unlocked-svgrepo-com.svg')}}"/>
          <img id="unlock" class="procedit_unlocked" onclick="editor.editor_mode='edit'; changeMode('unlock');" style="display:none;" src="{{url_for('static', filename='locked-svgrepo-com.svg')}}"/>
        </div>
        
        <div class="Help" id="cheat" style="display:none">Cheatsheet:
            <ul>
                <li>Press Delete to remove node</li>
                <li>Pull from left column to editor to create node</li>
                <li>Clear removes everything</li>
                <li>Export exports to JSON</li>
                <li>Inputs are left</li>
                <li>Outputs are right</li>
                <li>Double-click to add new routing point (buggy)</li>
            </ul>
        </div>
        <div class="bar-zoom">
          <img draggable="false" class="procedit_zoomout" onclick="editor.zoom_out()" src="{{url_for('static', filename='zoom-out-svgrepo-com.svg')}}"/>
          <img draggable="false" class="procedit_zoomreset" onclick="editor.zoom_reset()" src="{{url_for('static', filename='compass-svgrepo-com.svg')}}"/>
          <img draggable="false" class="procedit_zoomin" onclick="editor.zoom_in()" src="{{url_for('static', filename='zoom-in-svgrepo-com.svg')}}"/>
        </div>
      </div>
    </div>
  </div>


<script>
	dragElement(document.getElementById("inspector"));

function dragElement(elmnt) {
  var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  if (document.getElementById(elmnt.id + "header")) {
    // if present, the header is where you move the DIV from:
    document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
  } else {
    // otherwise, move the DIV from anywhere inside the DIV:
    elmnt.onmousedown = dragMouseDown;
  }

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;
  }
}

function hide_or_show(element) {
  var x = document.getElementById(element);
  if (x.style.display === "none") {
    x.style.display = "block";
  } else {
    x.style.display = "none";
  }
} 

</script>

    <script>
    // Shamelessly stolen
    var id = document.getElementById("drawflow");
    const editor = new Drawflow(id);
    editor.reroute = false;
    editor.curvature = 0;
    editor.reroute_fix_curvature = false;
    editor.force_first_input = true;

    editor.start();

    editor.on('nodeCreated', function(id) {
      console.log("Node created " + id);
    })

    editor.on('nodeRemoved', function(id) {
      console.log("Node removed " + id);
    })

    editor.on('nodeSelected', function(id) {
    // When this method is called it should load all
    // relevant data into the object inspector
    // if the inspector is visible

    // if it is not visible, it should skip the loading step
    // however, when it does become visible
    // the data should be loaded anyways
      console.log("Node selected " + id);
    })

    editor.on('moduleCreated', function(name) {
      console.log("Module Created " + name);
    })

    editor.on('moduleChanged', function(name) {
      console.log("Module Changed " + name);
    })

    editor.on('connectionCreated', function(connection) {
      console.log('Connection created');
      console.log(connection);
    })

    editor.on('connectionRemoved', function(connection) {
      console.log('Connection removed');
      console.log(connection);
    })
    
    editor.on('nodeMoved', function(id) {
        // console.log("Node moved " + id);
        const module = editor.getModuleFromNodeId(id);
        const data = editor.getNodeFromId(id);
        const pos_x = data.pos_x;
        const pos_y = data.pos_y;

        
        // Fix position: //  Logic Here. 
        editor.drawflow.drawflow[module].data[id].pos_x = pos_x + 1;
        editor.drawflow.drawflow[module].data[id].pos_y = pos_y + 1;
        document.getElementById(`node-${id}`).style.left = (pos_x + 1) + "px";
        document.getElementById(`node-${id}`).style.top = (pos_y + 1) + "px";
        editor.updateConnectionNodes(`node-${id}`);
        console.log("Node moved " + id);
    })

    editor.on('zoom', function(zoom) {
      console.log('Zoom level ' + zoom);
    })

    editor.on('translate', function(position) {
      console.log('Translate x:' + position.x + ' y:'+ position.y);
    })

    editor.on('addReroute', function(id) {
      console.log("Reroute added " + id);
    })

    editor.on('removeReroute', function(id) {
      console.log("Reroute removed " + id);
    })
    /* DRAG EVENT */

    /* Mouse and Touch Actions */

    var elements = document.getElementsByClassName('drag-drawflow');
    for (var i = 0; i < elements.length; i++) {
      elements[i].addEventListener('touchend', drop, false);
      elements[i].addEventListener('touchmove', positionMobile, false);
      elements[i].addEventListener('touchstart', drag, false );
    }

    var mobile_item_selec = '';
    var mobile_last_move = null;
   function positionMobile(ev) {
     mobile_last_move = ev;
   }

   function allowDrop(ev) {
      ev.preventDefault();
    }

    function drag(ev) {
      if (ev.type === "touchstart") {
        mobile_item_selec = ev.target.closest(".drag-drawflow").getAttribute('data-node');
      } else {
      ev.dataTransfer.setData("node", ev.target.getAttribute('data-node'));

      // This is important for the function to drop elements onto the nodes later on
	  source_element = ev.target.className;
	  ev.dataTransfer.setData("element-type", source_element);

      }
    }
    function changeMode(option) {

    //console.log(lock.id);
      if(option == 'lock') {
        lock.style.display = 'none';
        unlock.style.display = 'block';
      } else {
        lock.style.display = 'block';
        unlock.style.display = 'none';
      }
  }
  
  function hideCheat(option) {
    if(option=='hide'){
        cs_shown.style.display="block";
        cs_hidden.style.display="none";
        cheat.style.display="none";
        
    }
    else {
        cs_shown.style.display="none";
        cs_hidden.style.display="block";
        cheat.style.display="block";
    }
    
    }
    
    
    function drop(ev) {
      if (ev.type === "touchend") {
        var parentdrawflow = document.elementFromPoint( mobile_last_move.touches[0].clientX, mobile_last_move.touches[0].clientY).closest("#drawflow");
        if(parentdrawflow != null && parentdrawflow.className == "drag-drawflow") {
          addNodeToDrawFlow(mobile_item_selec, mobile_last_move.touches[0].clientX, mobile_last_move.touches[0].clientY);
        }
        mobile_item_selec = '';
      } else {
       ev.preventDefault();
       var data = ev.dataTransfer.getData("node");

      addNodeToDrawFlow(data, ev.clientX, ev.clientY);
     
	  // TODO: Make this a better function
	  // This takes the element beneath the mouse so we know which element to drag & drop the IO connectors and HTML elements on to it
		  var add_element_x = event.clientX; 
		  var add_element_y = event.clientY;
			add_conn_element = document.elementFromPoint(add_element_x, add_element_y);
			console.log(add_conn_element);

	// If we drop onto the image, it will select the div of the image
	// this means we need to get the parent node of the image for it to work IF THE ID = ""
		console.log(add_conn_element.className);

		// Since it will give ANY div that we drop onto, we must make sure we are dropping into a legit node
		if(add_conn_element.className === "drawflow_content_node")
		{
			add_conn_element = add_conn_element.parentNode;
			console.log('drawflow_content_node: ' + String(add_conn_element));
		}

		if(add_conn_element.className === "drawflow-node pnode" || add_conn_element.className === "drawflow-node pnode selected")
		{
			
	  		// Get the class of dragged element
			element_type = ev.dataTransfer.getData("element-type");
			console.log("Class name source: " + element_type);
			console.log('add_con_element id: ' + add_conn_element.id);
			add_io_ondrop(element_type, add_conn_element.id);
		}
		
	  }


	  function add_io_ondrop(element_name, node_id)
	  {
	  	// This is a hack because drawflow acts strange
	  	// Suspect: Inconsistency in Drawflow of use of "node-x" v "x" as ID
	  	
		node_id = node_id.substring(node_id.indexOf("-") + 1);
		console.log(node_id);

	  	if(element_type === "drag-input-connector"){
				editor.addNodeInput(node_id);
		}
			if(element_type === "drag-output-connector"){
				editor.addNodeOutput(node_id);
			}
	  }
      
      function addNodeToDrawFlow(name, pos_x, pos_y) {
      console.log(name.className);
	      if(editor.editor_mode === 'fixed') {
	        return false;
	      }
	      pos_x = pos_x * ( editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)) - (editor.precanvas.getBoundingClientRect().x * ( editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)));
	      pos_y = pos_y * ( editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)) - (editor.precanvas.getBoundingClientRect().y * ( editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)));

		fpath = Flask.url_for("static", {"filename":"themes/{{stf.theme.data}}/"+String(name)});
		// In simplest configuration, just draw image onto the canvas
		// There are probably better ways to do this but alas I am no computer scientist
		var pe_html = String(`<img draggable="false" src='` + fpath + `'></img>`);

		// name, inputs, outputs, pos_x, pos_y, class name, data, html or name of registered node, typenode

		// TODO: Fix this
		// Description: For reasons unbeknownst to man JavaScript believes that "null" is a string.
		// Therefor, we have to treat it as such.
		// IRONICALLY, if the name is set empty, it also does not count as null, but as a string. 
		console.log(typeof name);
		if(name != "null" && name != ""){
			editor.addNode('', 0,0, pos_x, pos_y,'pnode', {}, pe_html);
			}
	    }
   }
        </script>
</div>
{% endblock %}
	
